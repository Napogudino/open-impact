{
    "docs": [
        {
            "location": "/", 
            "text": "Google Earth Engine\n\n\nGoogle Earth Engine is a cloud based analysis platform that allows for an indexable and queriable raster and vector environment while including and expanding on raster capabilities. It allows for users to perform large scale analysis on multiple assets a large number of which it actively ingests and maintains. While mainintaing one of the world's largest repository of open source and distrubutable datasets, it allows you to scale and fit analysis based on your needs from local to global analysis. The analysis is performed using a javascript or python environment depending on the need and the results are repeatable and shareable as research outputs.\n\n\n\n\nYou can read more about the Google Earth Engine platform \nhere\n\n\n\n\nThese set of tutorials in this workshop will introduce you to methods in getting imagery onto the Google Earth Engine platform, and how do you quickly visualize and analyze the datasets with the GEE platform. With the multitude of tools and possibilities of building your own analysis tools and toolchains.\n\n\nFor more information and developer guide on Google Earth Engine you can visit their \ndeveloper console\n.\n\n\nTo have a look at all rasters that Google Earth Engine serves directly you can \nfind the raster list here\n\n\n\n\nAnd the list of \nvector datasets can be found here", 
            "title": "Google Earth Engine"
        }, 
        {
            "location": "/#google-earth-engine", 
            "text": "Google Earth Engine is a cloud based analysis platform that allows for an indexable and queriable raster and vector environment while including and expanding on raster capabilities. It allows for users to perform large scale analysis on multiple assets a large number of which it actively ingests and maintains. While mainintaing one of the world's largest repository of open source and distrubutable datasets, it allows you to scale and fit analysis based on your needs from local to global analysis. The analysis is performed using a javascript or python environment depending on the need and the results are repeatable and shareable as research outputs.   You can read more about the Google Earth Engine platform  here   These set of tutorials in this workshop will introduce you to methods in getting imagery onto the Google Earth Engine platform, and how do you quickly visualize and analyze the datasets with the GEE platform. With the multitude of tools and possibilities of building your own analysis tools and toolchains.  For more information and developer guide on Google Earth Engine you can visit their  developer console .  To have a look at all rasters that Google Earth Engine serves directly you can  find the raster list here   And the list of  vector datasets can be found here", 
            "title": "Google Earth Engine"
        }, 
        {
            "location": "/projects/gee/", 
            "text": "Registering for a Google Earth Engine Account\n\n\nIf you don\u2019t have a developer account \nsign up for one here\n and make sure you follow the \ninstructions\n to install the python CLI.\n\n\n\n\nThe API and the CLI gets updated frequently and as does the install process as needed so you can read the \nlatest instructions at the page.\n\n\nGetting access to Clinic Repos\n\n\nIn case you haven't filled out \nthis form yet\n please do so we have a quick tally and your email address(more specifically the email associated with your Google Earth Engine account)", 
            "title": "Account Setup"
        }, 
        {
            "location": "/projects/gee/#registering-for-a-google-earth-engine-account", 
            "text": "If you don\u2019t have a developer account  sign up for one here  and make sure you follow the  instructions  to install the python CLI.   The API and the CLI gets updated frequently and as does the install process as needed so you can read the  latest instructions at the page.", 
            "title": "Registering for a Google Earth Engine Account"
        }, 
        {
            "location": "/projects/gee/#getting-access-to-clinic-repos", 
            "text": "In case you haven't filled out  this form yet  please do so we have a quick tally and your email address(more specifically the email associated with your Google Earth Engine account)", 
            "title": "Getting access to Clinic Repos"
        }, 
        {
            "location": "/projects/housekeeping/", 
            "text": "Housekeeping and Setup\n\n\nFor most users data usage often boils down to the software you use to analyze and manipulate images and how you are going to work with them. So here are going to do some housekeeping and setup depending on which tools and setup you are most comfortable with\n\n\n1) Google Earth Engine(GEE) Command Line Interface(CLI) Setup\n\n\nThis assumes that you have registered for a Google Earth Engine account but also installed its client. Incase you have missed it go to their \nmain reference page for installation of their python client\n. Since you can consume Earth Engine using both Javascript(in browser) and Python(locally) the interaction would depend on the scale of your tasks and what you wish your achieve as your end result. Once installed make sure you authenticate your earth engine client and then your CLI should give you the following options\n\n\n\n\n2) Adding additional Images\n\n\nFor the simplest users getting images into GEE begins with the Image upload tool located inside GEE. Once you have added the filename you can edit additional metadata such as start time, cloud cover information if you have that from the metadata file among other things. This tool does not have a way for you to ingest any metadata automatically so it has to be fed manually.\n\n\nThe image name is automatically filled in with the filename that you select when uploading.\n\n\n\n\nNote you cannot select more than one image and upload as a single image if they overlap each other. To handle which we have the concept of image collections. Where you can upload many images. To import images into collections, you have to either import them manually as images first and then copy them into the collection one by one or for now use an external tool to help such as using the Google Earth Engine CLI.\n\n\nIncase you have a Google Cloud Storage bucket you can also push images automatically to be ingested into GEE. Though this requires interaction with gsutil and starting ingestion function for each image. The GEE guide for image ingestion can be \nfound here", 
            "title": "Basic Housekeeping and Setup"
        }, 
        {
            "location": "/projects/housekeeping/#housekeeping-and-setup", 
            "text": "For most users data usage often boils down to the software you use to analyze and manipulate images and how you are going to work with them. So here are going to do some housekeeping and setup depending on which tools and setup you are most comfortable with", 
            "title": "Housekeeping and Setup"
        }, 
        {
            "location": "/projects/housekeeping/#1-google-earth-enginegee-command-line-interfacecli-setup", 
            "text": "This assumes that you have registered for a Google Earth Engine account but also installed its client. Incase you have missed it go to their  main reference page for installation of their python client . Since you can consume Earth Engine using both Javascript(in browser) and Python(locally) the interaction would depend on the scale of your tasks and what you wish your achieve as your end result. Once installed make sure you authenticate your earth engine client and then your CLI should give you the following options", 
            "title": "1) Google Earth Engine(GEE) Command Line Interface(CLI) Setup"
        }, 
        {
            "location": "/projects/housekeeping/#2-adding-additional-images", 
            "text": "For the simplest users getting images into GEE begins with the Image upload tool located inside GEE. Once you have added the filename you can edit additional metadata such as start time, cloud cover information if you have that from the metadata file among other things. This tool does not have a way for you to ingest any metadata automatically so it has to be fed manually.  The image name is automatically filled in with the filename that you select when uploading.   Note you cannot select more than one image and upload as a single image if they overlap each other. To handle which we have the concept of image collections. Where you can upload many images. To import images into collections, you have to either import them manually as images first and then copy them into the collection one by one or for now use an external tool to help such as using the Google Earth Engine CLI.  Incase you have a Google Cloud Storage bucket you can also push images automatically to be ingested into GEE. Though this requires interaction with gsutil and starting ingestion function for each image. The GEE guide for image ingestion can be  found here", 
            "title": "2) Adding additional Images"
        }, 
        {
            "location": "/projects/images/", 
            "text": "Images in Earth Engine\n\n\nIn the GEE environment images are stored in Cloud Optimized Geospatial tiles instead of a single image which allows for running an analysis this scale. This means that though the input imagery comes in know formats such as geotiff , MrSid and img these datasets post ingestion into GEE are converted into tiles that are used for at scale analysis. All images that are ingested into either GEE(s) Raster Catalog or your own personal folder and stored in folder or collections of images as you would expect to see when doing deep time stack analysis.\n\n\n\n\nThese images have defined data type,scales and projections along with some default properties such as an index and ID among other system properties. So we can query these properties, print them and add them\n\n\n//Add an image\n\n\nvar\n \nimage\n=\nee\n.\nImage\n(\nLANDSAT/LT05/C01/T1_SR/LT05_025039_19841105\n)\n\n\nprint\n(\nSingle Image\n,\nimage\n)\n\n\n\n//Center the Map to the image and add the image\n\n\nMap\n.\ncenterObject\n(\ngeometry\n,\n10\n)\n\n\nMap\n.\naddLayer\n(\nimage\n,\nvis\n,\nImage\n)\n\n\n\n//Clip an image\n\n\nvar\n \nclipped\n=\nimage\n.\nclip\n(\ngeometry\n)\n\n\nMap\n.\naddLayer\n(\nclipped\n,\nvis\n,\nClipped Image\n)", 
            "title": "Images"
        }, 
        {
            "location": "/projects/images/#images-in-earth-engine", 
            "text": "In the GEE environment images are stored in Cloud Optimized Geospatial tiles instead of a single image which allows for running an analysis this scale. This means that though the input imagery comes in know formats such as geotiff , MrSid and img these datasets post ingestion into GEE are converted into tiles that are used for at scale analysis. All images that are ingested into either GEE(s) Raster Catalog or your own personal folder and stored in folder or collections of images as you would expect to see when doing deep time stack analysis.   These images have defined data type,scales and projections along with some default properties such as an index and ID among other system properties. So we can query these properties, print them and add them  //Add an image  var   image = ee . Image ( LANDSAT/LT05/C01/T1_SR/LT05_025039_19841105 )  print ( Single Image , image )  //Center the Map to the image and add the image  Map . centerObject ( geometry , 10 )  Map . addLayer ( image , vis , Image )  //Clip an image  var   clipped = image . clip ( geometry )  Map . addLayer ( clipped , vis , Clipped Image )", 
            "title": "Images in Earth Engine"
        }, 
        {
            "location": "/projects/imagecollection/", 
            "text": "Image Collections in Earth Engine\n\n\nWhile single images are great to do quick analytics, the true power of the Earth Engine environment comes with the possibility of looking at really large and heavy image collections and to be able to push analysis towards the data, rather than the need for the data to travel at all. In the GEE environment image collections have their own characteristic setup and are composted with single images that we discussed earlier. They can often have the same or different band structure but generally share a similar metadata structure for filtering and querying.\n\n\nLarge scale image collections such as Landsat and Sentinel image collections are ingested on the fly and are actively maintained till there imagery and processing pipelines feeds are maintained byt he agencies supplying the imagery. Images as well as image collections can be moved into GEE environment to allow you to use both your data and the GEE catalog data within the same platform.\n\n\nFor those who are concerned with access to datasets, this means that though Earth Engine allows an easier way to share datasets across users, private folder, collections and imagery are private and are not here the section from their \nTerms and Conditions page\n\n\nIntellectual Property Rights. Except as expressly set forth in this Agreement,\nthis Agreement does not grant either party any rights, implied or otherwise,\nto the other\u2019s content or any of the other\u2019s intellectual property.\nAs between the parties, Customer owns all Intellectual Property Rights\nin Customer Data, Customer Code, and Application(s), and Google owns\nall Intellectual Property Rights in the Services and Software.\n\n\nThese image collection as well as individual imaegs again have defined data type,scales and projections along with some default properties such as an index and ID among other system properties. So we can query these properties, print them and add them\n\n\n//Add an image collection\n\n\nvar\n \ncollection\n=\nee\n.\nImageCollection\n(\nLANDSAT/LT05/C01/T1_SR\n)\n\n\n\n//Filtering an Image Collection\n\n\nvar\n \nfiltered\n=\ncollection\n.\nfilterMetadata\n(\nWRS_PATH\n,\nequals\n,\n25\n)\n\n\n.\nfilterMetadata\n(\nWRS_ROW\n,\nequals\n,\n39\n).\nfilterMetadata\n(\nCLOUD_COVER\n,\nless_than\n,\n5\n)\n\n\n\n//print filtered collection properties\n\n\nprint\n(\nFiltered Collection\n,\nfiltered\n)\n\n\n\n\n\nTo have a look at all of the raster catalog you can find them \nlisted here", 
            "title": "Image Collection"
        }, 
        {
            "location": "/projects/imagecollection/#image-collections-in-earth-engine", 
            "text": "While single images are great to do quick analytics, the true power of the Earth Engine environment comes with the possibility of looking at really large and heavy image collections and to be able to push analysis towards the data, rather than the need for the data to travel at all. In the GEE environment image collections have their own characteristic setup and are composted with single images that we discussed earlier. They can often have the same or different band structure but generally share a similar metadata structure for filtering and querying.  Large scale image collections such as Landsat and Sentinel image collections are ingested on the fly and are actively maintained till there imagery and processing pipelines feeds are maintained byt he agencies supplying the imagery. Images as well as image collections can be moved into GEE environment to allow you to use both your data and the GEE catalog data within the same platform.  For those who are concerned with access to datasets, this means that though Earth Engine allows an easier way to share datasets across users, private folder, collections and imagery are private and are not here the section from their  Terms and Conditions page  Intellectual Property Rights. Except as expressly set forth in this Agreement,\nthis Agreement does not grant either party any rights, implied or otherwise,\nto the other\u2019s content or any of the other\u2019s intellectual property.\nAs between the parties, Customer owns all Intellectual Property Rights\nin Customer Data, Customer Code, and Application(s), and Google owns\nall Intellectual Property Rights in the Services and Software.  These image collection as well as individual imaegs again have defined data type,scales and projections along with some default properties such as an index and ID among other system properties. So we can query these properties, print them and add them  //Add an image collection  var   collection = ee . ImageCollection ( LANDSAT/LT05/C01/T1_SR )  //Filtering an Image Collection  var   filtered = collection . filterMetadata ( WRS_PATH , equals , 25 )  . filterMetadata ( WRS_ROW , equals , 39 ). filterMetadata ( CLOUD_COVER , less_than , 5 )  //print filtered collection properties  print ( Filtered Collection , filtered )   To have a look at all of the raster catalog you can find them  listed here", 
            "title": "Image Collections in Earth Engine"
        }, 
        {
            "location": "/projects/functions/", 
            "text": "Functions in Earth Engine\n\n\nWhile single image operations are direct and can be applied to the imagery for a one to one result. Applying any kind of analysis on a single image means you have to call the image and run the analysis which is quick and easy. To be able to turn this same into a function that you can iterate over an entire collection requires us to convert a single analysis to a function. A function is then mapped or run over an entire collection. To avoid any errors make sure that the collection images are consistent and have same name and number of band and characteristics.\n\n\nFor this setup we look at how we added Landsat 5 Surface Reflectance data earlier , filtering it using WRS Path and Row and further using Cloud cover for the scene. The next step we are building an function to calculate Normalized Difference Vegetation Index (NDVI) over the entire collection which takes an image collection and iteratively passes an image to the function. The resultant structure is also an image collection where we are returning a single band which is the NDVI. Note that we also renamed the band to NDVI since they are not autorenamed\n\n\n//Add an image collection\n\n\nvar\n \ncollection\n=\nee\n.\nImageCollection\n(\nLANDSAT/LT05/C01/T1_SR\n)\n\n\n\n//Filtering an Image Collection\n\n\nvar\n \nfiltered\n=\ncollection\n.\nfilterMetadata\n(\nWRS_PATH\n,\nequals\n,\n25\n)\n\n\n.\nfilterMetadata\n(\nWRS_ROW\n,\nequals\n,\n39\n).\nfilterMetadata\n(\nCLOUD_COVER\n,\nless_than\n,\n5\n)\n\n\n\n//print filtered collection properties\n\n\nprint\n(\nFiltered Collection\n,\nfiltered\n)\n\n\n\n\n/*=====================================================================================*/\n\n\n//Writing a function\n\n\nvar\n \naddNDVI\n \n=\n \nfunction\n(\nimage\n)\n \n{\n\n  \nvar\n \nndvi\n \n=\n \nimage\n.\nnormalizedDifference\n([\nB4\n,\n \nB3\n]).\nrename\n(\nNDVI\n);\n\n  \nreturn\n \nndvi\n;\n\n\n};\n\n\n\nvar\n \nndvicoll\n=\nfiltered\n.\nmap\n(\naddNDVI\n)\n\n\nprint\n(\nNDVI Collection\n,\nndvicoll\n)\n\n\n\n//Let\ns add a palette for us to show the results\n\n\nvar\n \nndvivis\n \n=\n \n{\nopacity\n:\n1\n,\nbands\n:\n[\nNDVI\n],\nmin\n:-\n0.5182320475578308\n,\nmax\n:\n0.7803871631622314\n,\npalette\n:\n[\nd49e8a\n,\nffcfb4\n,\necffcf\n,\n94ff8d\n,\n3eff56\n,\n15cc23\n]};\n\n\n\n//Add the first of the result\n\n\nMap\n.\naddLayer\n(\nee\n.\nImage\n(\nndvicoll\n.\nfirst\n()),\nndvivis\n,\nNDVI\n)", 
            "title": "Functions"
        }, 
        {
            "location": "/projects/functions/#functions-in-earth-engine", 
            "text": "While single image operations are direct and can be applied to the imagery for a one to one result. Applying any kind of analysis on a single image means you have to call the image and run the analysis which is quick and easy. To be able to turn this same into a function that you can iterate over an entire collection requires us to convert a single analysis to a function. A function is then mapped or run over an entire collection. To avoid any errors make sure that the collection images are consistent and have same name and number of band and characteristics.  For this setup we look at how we added Landsat 5 Surface Reflectance data earlier , filtering it using WRS Path and Row and further using Cloud cover for the scene. The next step we are building an function to calculate Normalized Difference Vegetation Index (NDVI) over the entire collection which takes an image collection and iteratively passes an image to the function. The resultant structure is also an image collection where we are returning a single band which is the NDVI. Note that we also renamed the band to NDVI since they are not autorenamed  //Add an image collection  var   collection = ee . ImageCollection ( LANDSAT/LT05/C01/T1_SR )  //Filtering an Image Collection  var   filtered = collection . filterMetadata ( WRS_PATH , equals , 25 )  . filterMetadata ( WRS_ROW , equals , 39 ). filterMetadata ( CLOUD_COVER , less_than , 5 )  //print filtered collection properties  print ( Filtered Collection , filtered )  /*=====================================================================================*/  //Writing a function  var   addNDVI   =   function ( image )   { \n   var   ndvi   =   image . normalizedDifference ([ B4 ,   B3 ]). rename ( NDVI ); \n   return   ndvi ;  };  var   ndvicoll = filtered . map ( addNDVI )  print ( NDVI Collection , ndvicoll )  //Let s add a palette for us to show the results  var   ndvivis   =   { opacity : 1 , bands : [ NDVI ], min :- 0.5182320475578308 , max : 0.7803871631622314 , palette : [ d49e8a , ffcfb4 , ecffcf , 94ff8d , 3eff56 , 15cc23 ]};  //Add the first of the result  Map . addLayer ( ee . Image ( ndvicoll . first ()), ndvivis , NDVI )", 
            "title": "Functions in Earth Engine"
        }, 
        {
            "location": "/projects/reducers/", 
            "text": "Reducers \n Charts in Earth Engine\n\n\nWhile single image operations are direct and can be applied to the imagery for a one to one result. Applying any kind of analysis on a single image means you have to call the image and run the analysis which is quick and easy. To be able to turn this same into a function that you can iterate over an entire collection requires us to convert a single analysis to a function. A function is then mapped or run over an entire collection. To avoid any errors make sure that the collection images are consistent and have same name and number of band and characteristics.\n\n\n\n\nSource: \nImage Collection Reductions from Google Earth Engine\n\n\nFor this setup we look at how we added Landsat 5 Surface Reflectance data earlier , filtering it using WRS Path and Row and further using Cloud cover for the scene. The next step we are building an function to calculate Normalized Difference Vegetation Index (NDVI) over the entire collection which takes an image collection and iteratively passes an image to the function. The resultant structure is also an image collection where we are returning a single band which is the NDVI. Note that we also renamed the band to NDVI since they are not autorenamed. Now the additional step we added here was running the produced collection through a median reducer. We can then print the median values. The last step we create a setup for the chart and the plot the chart of the median\n\n\n/*Add some field points and name the geometry\n\n\nas field this script won\nt work till then*/\n\n\n\n//Add an image collection\n\n\nvar\n \ncollection\n=\nee\n.\nImageCollection\n(\nLANDSAT/LT05/C01/T1_SR\n)\n\n\n\n//Filtering an Image Collection\n\n\nvar\n \nfiltered\n=\ncollection\n.\nfilterMetadata\n(\nWRS_PATH\n,\nequals\n,\n25\n)\n\n\n.\nfilterMetadata\n(\nWRS_ROW\n,\nequals\n,\n39\n).\nfilterMetadata\n(\nCLOUD_COVER\n,\nless_than\n,\n5\n)\n\n\n\n//print filtered collection properties\n\n\nprint\n(\nFiltered Collection\n,\nfiltered\n)\n\n\n\n\n/*==================================================*/\n\n\n//Writing a function\n\n\nvar\n \naddNDVI\n \n=\n \nfunction\n(\nimage\n)\n \n{\n\n  \nvar\n \nndvi\n \n=\n \nimage\n.\nnormalizedDifference\n([\nB4\n,\n \nB3\n]).\nrename\n(\nNDVI\n);\n\n  \nreturn\n \nndvi\n;\n\n\n};\n\n\n\nvar\n \nndvicoll\n=\nfiltered\n.\nmap\n(\naddNDVI\n)\n\n\nprint\n(\nNDVI Collection\n,\nndvicoll\n)\n\n\n\n//Let\ns add a palette for us to show the results\n\n\nvar\n \nndvivis\n \n=\n \n{\nopacity\n:\n1\n,\nbands\n:\n[\nNDVI\n],\nmin\n:-\n0.5182320475578308\n,\nmax\n:\n0.7803871631622314\n,\npalette\n:\n[\nd49e8a\n,\nffcfb4\n,\necffcf\n,\n94ff8d\n,\n3eff56\n,\n15cc23\n]};\n\n\n\n//Add the first of the result\n\n\nMap\n.\naddLayer\n(\nee\n.\nImage\n(\nndvicoll\n.\nfirst\n()),\nndvivis\n,\nNDVI\n)\n\n\n\n//Add an reducer\n\n\nvar\n \nndviav\n=\nndvicoll\n.\nreduce\n(\nee\n.\nReducer\n.\nmedian\n());\n\n\n\nMap\n.\naddLayer\n(\nndviav\n.\nselect\n(\nNDVI_median\n).\nrename\n(\nNDVI\n),\nndvivis\n,\nNDVI Median\n)\n\n\nprint\n(\nndviav\n)\n\n\n\n\n\n\n\n\nTop: Field points to look at median NDVI, Bottom: Chart generated from field point\n\n\nvar\n \nndvionly\n=\nndviav\n.\nselect\n(\nNDVI_median\n).\nrename\n(\nNDVI\n)\n\n\n\nvar\n \nchart\n \n=\n \nui\n.\nChart\n.\nimage\n.\nbyRegion\n({\n\n  \nimage\n:\n \nndvionly\n,\n\n  \nregions\n:\n \nfield\n,\n\n  \nscale\n:\n \n30\n\n\n});\n\n\nchart\n.\nsetOptions\n({\n\n  \ntitle\n:\n \nCharting NDVI\n,\n\n  \nvAxis\n:\n \n{\n\n    \ntitle\n:\n \nNDVI\n\n  \n},\n\n  \nlegend\n:\n \nnone\n,\n\n  \nlineWidth\n:\n \n1\n,\n\n  \npointSize\n:\n \n4\n\n\n});\n\n\n\nprint\n(\nchart\n);", 
            "title": "Reducers and Charts"
        }, 
        {
            "location": "/projects/reducers/#reducers-charts-in-earth-engine", 
            "text": "While single image operations are direct and can be applied to the imagery for a one to one result. Applying any kind of analysis on a single image means you have to call the image and run the analysis which is quick and easy. To be able to turn this same into a function that you can iterate over an entire collection requires us to convert a single analysis to a function. A function is then mapped or run over an entire collection. To avoid any errors make sure that the collection images are consistent and have same name and number of band and characteristics.   Source:  Image Collection Reductions from Google Earth Engine  For this setup we look at how we added Landsat 5 Surface Reflectance data earlier , filtering it using WRS Path and Row and further using Cloud cover for the scene. The next step we are building an function to calculate Normalized Difference Vegetation Index (NDVI) over the entire collection which takes an image collection and iteratively passes an image to the function. The resultant structure is also an image collection where we are returning a single band which is the NDVI. Note that we also renamed the band to NDVI since they are not autorenamed. Now the additional step we added here was running the produced collection through a median reducer. We can then print the median values. The last step we create a setup for the chart and the plot the chart of the median  /*Add some field points and name the geometry  as field this script won t work till then*/  //Add an image collection  var   collection = ee . ImageCollection ( LANDSAT/LT05/C01/T1_SR )  //Filtering an Image Collection  var   filtered = collection . filterMetadata ( WRS_PATH , equals , 25 )  . filterMetadata ( WRS_ROW , equals , 39 ). filterMetadata ( CLOUD_COVER , less_than , 5 )  //print filtered collection properties  print ( Filtered Collection , filtered )  /*==================================================*/  //Writing a function  var   addNDVI   =   function ( image )   { \n   var   ndvi   =   image . normalizedDifference ([ B4 ,   B3 ]). rename ( NDVI ); \n   return   ndvi ;  };  var   ndvicoll = filtered . map ( addNDVI )  print ( NDVI Collection , ndvicoll )  //Let s add a palette for us to show the results  var   ndvivis   =   { opacity : 1 , bands : [ NDVI ], min :- 0.5182320475578308 , max : 0.7803871631622314 , palette : [ d49e8a , ffcfb4 , ecffcf , 94ff8d , 3eff56 , 15cc23 ]};  //Add the first of the result  Map . addLayer ( ee . Image ( ndvicoll . first ()), ndvivis , NDVI )  //Add an reducer  var   ndviav = ndvicoll . reduce ( ee . Reducer . median ());  Map . addLayer ( ndviav . select ( NDVI_median ). rename ( NDVI ), ndvivis , NDVI Median )  print ( ndviav )     Top: Field points to look at median NDVI, Bottom: Chart generated from field point  var   ndvionly = ndviav . select ( NDVI_median ). rename ( NDVI )  var   chart   =   ui . Chart . image . byRegion ({ \n   image :   ndvionly , \n   regions :   field , \n   scale :   30  });  chart . setOptions ({ \n   title :   Charting NDVI , \n   vAxis :   { \n     title :   NDVI \n   }, \n   legend :   none , \n   lineWidth :   1 , \n   pointSize :   4  });  print ( chart );", 
            "title": "Reducers &amp; Charts in Earth Engine"
        }, 
        {
            "location": "/projects/multiyear/", 
            "text": "Multiyear Cloud Free Composites in Earth Engine\n\n\nOne of the most sought after functions in Earth Engine is the possibility of using deep time stack imagery to create cloud free composites. One of the simplest way of thinking about this is to use reducers that we talked about earlier, where we look at an entire stack of pixels and choose the median value of the distribution of pixel across stack and we end up getting a cloud free composite over the given time period. Depending on the number of images, the actual number of cloud free images in the overall stack your results may need more fine tune adjustments.\n\n\n\n\nMulti Year Composite: A single year is added FCC\n\n\nFor this setup we look at how we added Landsat 5 Surface Reflectance data earlier , filtering it using WRS Path and Row and further using Cloud cover for the scene. The next step we are building an function to calculate yearly composites from 1984 to 2010 using the Landsat 5 data. Note that this is another way of creating a function where we have inserted the map function and the collection inside the function so it can be run directly. We might be interested in sorting these collections using year and hence we set the year as a metadata for each image in the cloud free composite. Depending on the type of imagery another good way of creating cloud free composites is by using the pixel qa bit bands in the Landsat surface reflectance imagery.\n\n\n//Add an image collection\n\n\nvar\n \ncollection\n=\nee\n.\nImageCollection\n(\nLANDSAT/LT05/C01/T1_SR\n)\n\n\n\n//Filtering an Image Collection\n\n\nvar\n \nfiltered\n=\ncollection\n.\nfilterMetadata\n(\nWRS_PATH\n,\nequals\n,\n25\n)\n\n\n.\nfilterMetadata\n(\nWRS_ROW\n,\nequals\n,\n39\n).\nfilterMetadata\n(\nCLOUD_COVER\n,\nless_than\n,\n15\n)\n\n\n\n//print filtered collection properties\n\n\nprint\n(\nFiltered Collection\n,\nfiltered\n)\n\n\n\n//Create Multi Year Composite from Landsat 5 Surface Reflectance\n\n\nvar\n \nyears\n \n=\n \nee\n.\nList\n.\nsequence\n(\n1984\n,\n \n2010\n)\n\n\n\nvar\n \nmultiyear\n \n=\n \nee\n.\nImageCollection\n(\nyears\n\n  \n.\nmap\n(\nfunction\n(\ny\n)\n \n{\n\n    \nvar\n \nstart\n \n=\n \nee\n.\nDate\n.\nfromYMD\n(\ny\n,\n \n1\n,\n \n1\n)\n\n    \nvar\n \nend\n \n=\n \nstart\n.\nadvance\n(\n1\n,\n \nyear\n);\n\n    \nvar\n \nimage\n \n=\n \nfiltered\n.\nfilterDate\n(\nstart\n,\n \nend\n).\nmedian\n();\n\n    \nreturn\n \nimage\n.\nset\n(\nyear\n,\n \ny\n)\n\n\n}))\n\n\n\nprint\n(\nmultiyear\n);\n\n\n\n//Add a visualization\n\n\nvar\n \nvis\n \n=\n \n{\nopacity\n:\n1\n,\nbands\n:\n[\nB4\n,\nB3\n,\nB2\n],\nmin\n:-\n95.56918120427508\n,\nmax\n:\n2171.008347369839\n,\ngamma\n:\n1\n};\n\n\n\n//Add the Image\n\n\nMap\n.\naddLayer\n(\nee\n.\nImage\n(\nee\n.\nImageCollection\n(\nmultiyear\n).\nfirst\n()),\nvis\n,\nMedian from MultiYear\n)", 
            "title": "Multiyear Cloud free composites"
        }, 
        {
            "location": "/projects/multiyear/#multiyear-cloud-free-composites-in-earth-engine", 
            "text": "One of the most sought after functions in Earth Engine is the possibility of using deep time stack imagery to create cloud free composites. One of the simplest way of thinking about this is to use reducers that we talked about earlier, where we look at an entire stack of pixels and choose the median value of the distribution of pixel across stack and we end up getting a cloud free composite over the given time period. Depending on the number of images, the actual number of cloud free images in the overall stack your results may need more fine tune adjustments.   Multi Year Composite: A single year is added FCC  For this setup we look at how we added Landsat 5 Surface Reflectance data earlier , filtering it using WRS Path and Row and further using Cloud cover for the scene. The next step we are building an function to calculate yearly composites from 1984 to 2010 using the Landsat 5 data. Note that this is another way of creating a function where we have inserted the map function and the collection inside the function so it can be run directly. We might be interested in sorting these collections using year and hence we set the year as a metadata for each image in the cloud free composite. Depending on the type of imagery another good way of creating cloud free composites is by using the pixel qa bit bands in the Landsat surface reflectance imagery.  //Add an image collection  var   collection = ee . ImageCollection ( LANDSAT/LT05/C01/T1_SR )  //Filtering an Image Collection  var   filtered = collection . filterMetadata ( WRS_PATH , equals , 25 )  . filterMetadata ( WRS_ROW , equals , 39 ). filterMetadata ( CLOUD_COVER , less_than , 15 )  //print filtered collection properties  print ( Filtered Collection , filtered )  //Create Multi Year Composite from Landsat 5 Surface Reflectance  var   years   =   ee . List . sequence ( 1984 ,   2010 )  var   multiyear   =   ee . ImageCollection ( years \n   . map ( function ( y )   { \n     var   start   =   ee . Date . fromYMD ( y ,   1 ,   1 ) \n     var   end   =   start . advance ( 1 ,   year ); \n     var   image   =   filtered . filterDate ( start ,   end ). median (); \n     return   image . set ( year ,   y )  }))  print ( multiyear );  //Add a visualization  var   vis   =   { opacity : 1 , bands : [ B4 , B3 , B2 ], min :- 95.56918120427508 , max : 2171.008347369839 , gamma : 1 };  //Add the Image  Map . addLayer ( ee . Image ( ee . ImageCollection ( multiyear ). first ()), vis , Median from MultiYear )", 
            "title": "Multiyear Cloud Free Composites in Earth Engine"
        }, 
        {
            "location": "/projects/export/", 
            "text": "Export Images in Earth Engine\n\n\nWhen we are all said and done we still want to export the images. Google Earth Engine allows you to export images externally into two subsystems, a Google Cloud Storage Bucket(Free quota upto 5 GB) or Google Drive (This is tied to your overall quota). The method we are exploring right now is export to Google Drive, and then being able to import the analyzed image into any local tool or libraries. It is possible to export entire collections to drive using batch exports in the python API client. This avoids the need for you to click on the Run button everytime an export task has to be started.\n\n\n\n\nExport Window: Export Image to Google Drive\n\n\nFor this setup we look at how we added Landsat 5 Surface Reflectance data earlier , filtering it using WRS Path and Row and further using Cloud cover for the scene. The next step we are building an function to calculate yearly composites from 1984 to 2010 using the Landsat 5 data. Note that this is another way of creating a function where we have inserted the map function and the collection inside the function so it can be run directly. We might be interested in sorting these collections using year and hence we set the year as a metadata for each image in the cloud free composite. Depending on the type of imagery another good way of creating cloud free composites is by using the pixel qa bit bands in the Landsat surface reflectance imagery. The last step that is added is the Export to drive function, where we set up the image name, the image type, the scale and the region refers to areas over which we are exporting this imagery.\n\n\n//Add an image collection\n\n\nvar\n \ncollection\n=\nee\n.\nImageCollection\n(\nLANDSAT/LT05/C01/T1_SR\n)\n\n\n\n//Filtering an Image Collection\n\n\nvar\n \nfiltered\n=\ncollection\n.\nfilterMetadata\n(\nWRS_PATH\n,\nequals\n,\n25\n)\n\n\n.\nfilterMetadata\n(\nWRS_ROW\n,\nequals\n,\n39\n).\nfilterMetadata\n(\nCLOUD_COVER\n,\nless_than\n,\n15\n)\n\n\n\n//print filtered collection properties\n\n\nprint\n(\nFiltered Collection\n,\nfiltered\n)\n\n\n\n//Create Multi Year Composite from Landsat 5 Surface Reflectance\n\n\nvar\n \nyears\n \n=\n \nee\n.\nList\n.\nsequence\n(\n1984\n,\n \n2010\n)\n\n\n\nvar\n \nmultiyear\n \n=\n \nee\n.\nImageCollection\n(\nyears\n\n  \n.\nmap\n(\nfunction\n(\ny\n)\n \n{\n\n    \nvar\n \nstart\n \n=\n \nee\n.\nDate\n.\nfromYMD\n(\ny\n,\n \n1\n,\n \n1\n)\n\n    \nvar\n \nend\n \n=\n \nstart\n.\nadvance\n(\n1\n,\n \nyear\n);\n\n    \nvar\n \nimage\n \n=\n \nfiltered\n.\nfilterDate\n(\nstart\n,\n \nend\n).\nmedian\n();\n\n    \nreturn\n \nimage\n.\nset\n(\nyear\n,\n \ny\n)\n\n\n}))\n\n\n\nprint\n(\nmultiyear\n);\n\n\n\n//Add a visualization\n\n\nvar\n \nvis\n \n=\n \n{\nopacity\n:\n1\n,\nbands\n:\n[\nB4\n,\nB3\n,\nB2\n],\nmin\n:-\n95.56918120427508\n,\nmax\n:\n2171.008347369839\n,\ngamma\n:\n1\n};\n\n\n\n//Add the Image\n\n\nMap\n.\naddLayer\n(\nee\n.\nImage\n(\nee\n.\nImageCollection\n(\nmultiyear\n).\nfirst\n()),\nvis\n,\nMedian from MultiYear\n)\n\n\n\n//Export Imagery\n\n\nExport\n.\nimage\n.\ntoDrive\n({\n\n  \nimage\n:\nee\n.\nImage\n(\nee\n.\nImageCollection\n(\nmultiyear\n).\nfirst\n())\n\n  \n.\nselect\n([\nB1\n,\nB2\n,\nB3\n,\nB4\n,\nB5\n,\nB6\n,\nB7\n]).\ntoUint16\n(),\n\n  \ndescription\n:\n \nMedian-Image-Export\n,\n\n  \nfolder\n:\n \nEE-CSDMS-Test\n,\n\n  \nscale\n:\n30\n,\n\n  \nregion\n:\n \ngeometry\n,\n\n  \nmaxPixels\n:\n10\ne12\n\n\n})", 
            "title": "Earth Engine exports"
        }, 
        {
            "location": "/projects/export/#export-images-in-earth-engine", 
            "text": "When we are all said and done we still want to export the images. Google Earth Engine allows you to export images externally into two subsystems, a Google Cloud Storage Bucket(Free quota upto 5 GB) or Google Drive (This is tied to your overall quota). The method we are exploring right now is export to Google Drive, and then being able to import the analyzed image into any local tool or libraries. It is possible to export entire collections to drive using batch exports in the python API client. This avoids the need for you to click on the Run button everytime an export task has to be started.   Export Window: Export Image to Google Drive  For this setup we look at how we added Landsat 5 Surface Reflectance data earlier , filtering it using WRS Path and Row and further using Cloud cover for the scene. The next step we are building an function to calculate yearly composites from 1984 to 2010 using the Landsat 5 data. Note that this is another way of creating a function where we have inserted the map function and the collection inside the function so it can be run directly. We might be interested in sorting these collections using year and hence we set the year as a metadata for each image in the cloud free composite. Depending on the type of imagery another good way of creating cloud free composites is by using the pixel qa bit bands in the Landsat surface reflectance imagery. The last step that is added is the Export to drive function, where we set up the image name, the image type, the scale and the region refers to areas over which we are exporting this imagery.  //Add an image collection  var   collection = ee . ImageCollection ( LANDSAT/LT05/C01/T1_SR )  //Filtering an Image Collection  var   filtered = collection . filterMetadata ( WRS_PATH , equals , 25 )  . filterMetadata ( WRS_ROW , equals , 39 ). filterMetadata ( CLOUD_COVER , less_than , 15 )  //print filtered collection properties  print ( Filtered Collection , filtered )  //Create Multi Year Composite from Landsat 5 Surface Reflectance  var   years   =   ee . List . sequence ( 1984 ,   2010 )  var   multiyear   =   ee . ImageCollection ( years \n   . map ( function ( y )   { \n     var   start   =   ee . Date . fromYMD ( y ,   1 ,   1 ) \n     var   end   =   start . advance ( 1 ,   year ); \n     var   image   =   filtered . filterDate ( start ,   end ). median (); \n     return   image . set ( year ,   y )  }))  print ( multiyear );  //Add a visualization  var   vis   =   { opacity : 1 , bands : [ B4 , B3 , B2 ], min :- 95.56918120427508 , max : 2171.008347369839 , gamma : 1 };  //Add the Image  Map . addLayer ( ee . Image ( ee . ImageCollection ( multiyear ). first ()), vis , Median from MultiYear )  //Export Imagery  Export . image . toDrive ({ \n   image : ee . Image ( ee . ImageCollection ( multiyear ). first ()) \n   . select ([ B1 , B2 , B3 , B4 , B5 , B6 , B7 ]). toUint16 (), \n   description :   Median-Image-Export , \n   folder :   EE-CSDMS-Test , \n   scale : 30 , \n   region :   geometry , \n   maxPixels : 10 e12  })", 
            "title": "Export Images in Earth Engine"
        }, 
        {
            "location": "/citations/", 
            "text": "Earth Engine Citations and References\n\n\nCiting Google Earth Engine\n\n\nEarth Engine has been growing in use and popularity as an exercise in creating codes and datasets that are both shareable and large repeatable. You can cite them using a paper they wrote last year\n\n\nGorelick, Noel, Matt Hancher, Mike Dixon, Simon Ilyushchenko, David Thau, and Rebecca Moore.\"Google Earth Engine: Planetary-scale geospatial analysis for everyone.\" Remote Sensing of Environment 202 (2017): 18-27.\n\n\nReferences\n\n\n\n\nDevelopers Page Google Earth Engine\n\n\nGoogle Earth Engine API\n\n\nEarth Engine resources for higher education", 
            "title": "Citations & References"
        }, 
        {
            "location": "/citations/#earth-engine-citations-and-references", 
            "text": "", 
            "title": "Earth Engine Citations and References"
        }, 
        {
            "location": "/citations/#citing-google-earth-engine", 
            "text": "Earth Engine has been growing in use and popularity as an exercise in creating codes and datasets that are both shareable and large repeatable. You can cite them using a paper they wrote last year  Gorelick, Noel, Matt Hancher, Mike Dixon, Simon Ilyushchenko, David Thau, and Rebecca Moore.\"Google Earth Engine: Planetary-scale geospatial analysis for everyone.\" Remote Sensing of Environment 202 (2017): 18-27.", 
            "title": "Citing Google Earth Engine"
        }, 
        {
            "location": "/citations/#references", 
            "text": "Developers Page Google Earth Engine  Google Earth Engine API  Earth Engine resources for higher education", 
            "title": "References"
        }
    ]
}